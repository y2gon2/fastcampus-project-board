debug: false
management.endpoints.web.exposure.include: "*"

logging:
  level:
    com.fastcampus.projectboard: debug
    org.springframework.web.servlet: debug
    org.hibernate.type.descriptor.sql.BasicBinder: trace

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/board
    username: gon
    password: 2025
    driver-class-name: com.mysql.cj.jdbc.Driver

#    url: jdbc:h2:mem:testdb
#    username: sa
#    driver-class-name: org.h2.Driver
    # log 화면상 아래 내용 출력 확인
    # -> INFO 17032 --- [  restartedMain] o.s.b.a.h2.H2ConsoleAutoConfiguration    : H2 console available at '/h2-console'. Database available at 'jdbc:h2:mem:testdb'
    # http://localhost:8080/h2-console 접속 및 확인
  jpa:
    # 2023-09-21 11:25:41.334  WARN 6168 --- [  restartedMain] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default.
    #       Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
    # -> OSIV (Open Session In View)
    #    Repository 가 Domain data 를 가저와서 Service 로 전달
    #    -> data 를 DTO 로 바꿔서 controller 에 넘겨줌
    #    -> Controller 가  view info 및 model 을 DispatcherServlet (Filter Interceptor) 에 전달 하여 client response 진행
    #
    #   위 과정에서 보면 Transacton 의 session (Hibernate 에 의해 생성된) 의 작업은 service - controller 관계에서만 필요하다.
    #   그런데 open session in view 는 필요한 layer 이외 범위에서 (ex. service - repository) 에서도 Hibernate session 이 살아 있다.
    #   이러한 경우 session 을 매번 다시 생성하지 않아도 되기 때문에 개발에  편의성은 높아진다. (Lazy laading 활용이 용이)
    #   다만, 그러나 session 이 의도하지 않은 범위까지 살아 있으므로 설계 의도의 적합성에는 맞지 않을 수 있다.
    #   또한, DB connection 을 계속 잡고 있으므로써, 많은 트래픽 처리에서 성능 문제가 발생할 수 있다.
    open-in-view: false # or true (둘중 하나로 결정만 하면 warning 제거) default : true
    defer-datasource-initialization: true
    hibernate.ddl-auto: create
    show-sql: true
    properties:
      hibernate.format_sql: true
      hibernate.default_batch_fetch_size: 100
#  h2.console.enabled: true
  sql.init.mode: always

  # Spring data REST
  # spring data repository 를 자동으로 RESTful service 로 노출 시킬수 있게 만들어주는 라이브러리
  # 기존의 MVC pattern 에서 sprind data REST 를 사용하면 controller 와 model 의 구현 작업을 해당 라이브러리에서 내부적으로 처리되므로
  # DB CRUD 작업과 client REST 에서 처리되어야 할 data 처리과정이 단순한 경우 Spring data REST 를 사용하는 것이 작업량을 줄이는데 도움이 되지만
  # 그외 경우 직접 controller / model 을 작성하는 것이 나을 수 있음.
  # by ChatGPT
  # Spring Data REST는 CRUD 연산을 자동화하여 빠르게 RESTful API를 생성해 주는 장점이 있지만,
  # 복잡한 데이터 변환이나 비즈니스 로직이 필요한 경우에는 그러한 상황을 완벽하게 처리하기 어렵습니다.
  # 다음은 Spring Data REST를 사용할 때 고려해야 할 몇 가지 제약사항과 단점입니다:
  #
  # 복잡한 로직:
  # Spring Data REST는 기본적으로 간단한 CRUD 연산을 자동으로 처리해주지만,
  # 복잡한 비즈니스 로직이나 데이터 변환을 위해서는 별도의 컨트롤러를 구현해야 할 수 있습니다.
  #
  # 유연성 부족
  # 자동 생성된 API는 특정 규칙에 따라 만들어지므로, 원하는 엔드포인트 이름, 데이터 형식 등을 세밀하게 조정하기 어렵습니다.
  #
  # 보안
  # Spring Data REST는 자동으로 API를 노출시키기 때문에, 보안 적용을 따로 해주어야 하며 이를 놓치게 되면 심각한 보안 문제가 발생할 수 있습니다.
  #
  # 성능
  # 자동 생성된 API는 최적화되지 않았을 가능성이 있으므로, 특히 큰 데이터셋에서는 성능 이슈가 발생할 수 있습니다.
  #
  # 커스터마이징의 한계
  # Spring Data REST를 사용하면서 커스터마이징을 하려면, 여러 설정과 확장 포인트를 잘 알고 있어야 합니다. 그렇지 않으면 원하는 동작을 쉽게 구현하기 어렵습니다.
  #
  # 따라서, 데이터 구조의 변환이 복잡하거나 추가적인 서버 측 로직이 필요한 경우에는 Spring Data REST보다는
  # 일반적인 Spring MVC와 JPA, MongoDB 등을 직접 사용하여 API를 구현하는 것이 더 유연하고 제어력이 높을 수 있습니다.
  data.rest:
    base-path: /api

    # 우리가 가진 repository 를 확인하는데 해당 repository  를 REST 노출을 시킬것인가 에 대한 전략
    detection-strategy: annotated

  thymeleaf3:
    decoupled-logic: true # by ThymeleafConfig class

#---
#
#spring:
#  config.activate.on-profile: testdb
#  datasource:
#    url: jdbc:h2:mem:board;mode=mysql # mySQL mode 로 사용 (참고 : https://www.h2database.com/)
#    driverClassName: org.h2.Driver
#  sql.init.mode: always
#  test.database.replace: none
  # @ActiveProfiles("testdb") annotation 으로 test 에서 해당 setting 을 사용하려고 하지만
  # @DataJpaTest 를 적용하면 JPA 가 앞의 설정 조건을 무시하고 무조건 자체 setting 으로 진행을 해벼림
  # @AutoConfigureTestDatabse(replace = AutoConfigureTestDatabase.Replace.NONE) 사용
  # 그러면 Testdb 를 다시 설정하지 않고, 앞에 setting 된 db 를 그대로 사용할 수 있게 됨.
  # 그런데 해당 annotation 은 각 test class 에 매번 설정해줘야 한다.
  # 따라서 이 기능을 모든 test 에 전역적으로 사용하고 싶을 때
  # test.database.replace: none 으로 설정

---

spring:
  config.activate.on-profile: heroku
  datasource:
    url: ${JAWSDB_URL}
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa.hibernate.ddl-auto: create
  sql.init.mode: always